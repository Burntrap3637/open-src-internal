-- Gui to Lua
-- Version: 3.6

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Scroll = Instance.new("ScrollingFrame")
local Code = Instance.new("TextBox")
local Globals_ = Instance.new("TextLabel")
local Keywords_ = Instance.new("TextLabel")
local RemoteHighlight_ = Instance.new("TextLabel")
local Strings_ = Instance.new("TextLabel")
local Numbers_ = Instance.new("TextLabel")
local Comments_ = Instance.new("TextLabel")
local Custom_ = Instance.new("TextLabel")
local Tokens_ = Instance.new("TextLabel")
local Lines = Instance.new("TextLabel")
local LLine = Instance.new("Frame")
local Execute = Instance.new("TextButton")
local Clear = Instance.new("TextButton")
local Attach = Instance.new("TextButton")
local TextLabel = Instance.new("TextLabel")
local Close = Instance.new("TextButton")
local Open = Instance.new("TextButton")
local UICorner_2 = Instance.new("UICorner")

-- Properties:

ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.331182808, 0, 0.345208853, 0)
Frame.Size = UDim2.new(0, 467, 0, 273)

UICorner.Parent = Frame

Scroll.Name = "Scroll"
Scroll.Parent = Frame
Scroll.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
Scroll.BackgroundTransparency = 0.500
Scroll.BorderColor3 = Color3.fromRGB(27, 42, 53)
Scroll.BorderSizePixel = 0
Scroll.Position = UDim2.new(0.0357143879, 0, 0.136683986, 0)
Scroll.Size = UDim2.new(0.928730905, 0, 0.767038047, 0)
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.ScrollBarImageColor3 = Color3.fromRGB(63, 181, 254)
Scroll.ScrollBarThickness = 6

Code.Name = "Code"
Code.Parent = Scroll
Code.AnchorPoint = Vector2.new(1, 0)
Code.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Code.BackgroundTransparency = 1.000
Code.BorderColor3 = Color3.fromRGB(27, 42, 53)
Code.BorderSizePixel = 0
Code.Position = UDim2.new(0.979098141, 0, 0, 0)
Code.Selectable = false
Code.Size = UDim2.new(0.935374141, 0, 1, 0)
Code.ClearTextOnFocus = false
Code.Font = Enum.Font.Code
Code.MultiLine = true
Code.Text = ""
Code.TextColor3 = Color3.fromRGB(255, 255, 255)
Code.TextSize = 14.000
Code.TextXAlignment = Enum.TextXAlignment.Left
Code.TextYAlignment = Enum.TextYAlignment.Top

Globals_.Name = "Globals_"
Globals_.Parent = Code
Globals_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Globals_.BackgroundTransparency = 1.000
Globals_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Globals_.BorderSizePixel = 0
Globals_.Size = UDim2.new(1, 0, 1, 0)
Globals_.Font = Enum.Font.Code
Globals_.Text = ""
Globals_.TextColor3 = Color3.fromRGB(86, 156, 214)
Globals_.TextSize = 14.000
Globals_.TextXAlignment = Enum.TextXAlignment.Left
Globals_.TextYAlignment = Enum.TextYAlignment.Top

Keywords_.Name = "Keywords_"
Keywords_.Parent = Code
Keywords_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Keywords_.BackgroundTransparency = 1.000
Keywords_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Keywords_.BorderSizePixel = 0
Keywords_.Size = UDim2.new(0.999999881, 0, 1, 0)
Keywords_.ZIndex = 2
Keywords_.Font = Enum.Font.Code
Keywords_.Text = ""
Keywords_.TextColor3 = Color3.fromRGB(86, 156, 214)
Keywords_.TextSize = 14.000
Keywords_.TextXAlignment = Enum.TextXAlignment.Left
Keywords_.TextYAlignment = Enum.TextYAlignment.Top

RemoteHighlight_.Name = "RemoteHighlight_"
RemoteHighlight_.Parent = Code
RemoteHighlight_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RemoteHighlight_.BackgroundTransparency = 1.000
RemoteHighlight_.BorderColor3 = Color3.fromRGB(27, 42, 53)
RemoteHighlight_.BorderSizePixel = 0
RemoteHighlight_.Size = UDim2.new(1, 0, 1, 0)
RemoteHighlight_.ZIndex = 2
RemoteHighlight_.Font = Enum.Font.Code
RemoteHighlight_.Text = ""
RemoteHighlight_.TextColor3 = Color3.fromRGB(112, 255, 227)
RemoteHighlight_.TextSize = 14.000
RemoteHighlight_.TextXAlignment = Enum.TextXAlignment.Left
RemoteHighlight_.TextYAlignment = Enum.TextYAlignment.Top

Strings_.Name = "Strings_"
Strings_.Parent = Code
Strings_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Strings_.BackgroundTransparency = 1.000
Strings_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Strings_.BorderSizePixel = 0
Strings_.Size = UDim2.new(1, 0, 1, 0)
Strings_.ZIndex = 2
Strings_.Font = Enum.Font.Code
Strings_.Text = ""
Strings_.TextColor3 = Color3.fromRGB(214, 157, 133)
Strings_.TextSize = 14.000
Strings_.TextXAlignment = Enum.TextXAlignment.Left
Strings_.TextYAlignment = Enum.TextYAlignment.Top

Numbers_.Name = "Numbers_"
Numbers_.Parent = Code
Numbers_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Numbers_.BackgroundTransparency = 1.000
Numbers_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Numbers_.BorderSizePixel = 0
Numbers_.Size = UDim2.new(1, 0, 1, 0)
Numbers_.ZIndex = 2
Numbers_.Font = Enum.Font.Code
Numbers_.Text = ""
Numbers_.TextColor3 = Color3.fromRGB(181, 206, 168)
Numbers_.TextSize = 14.000
Numbers_.TextXAlignment = Enum.TextXAlignment.Left
Numbers_.TextYAlignment = Enum.TextYAlignment.Top

Comments_.Name = "Comments_"
Comments_.Parent = Code
Comments_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Comments_.BackgroundTransparency = 1.000
Comments_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Comments_.BorderSizePixel = 0
Comments_.Size = UDim2.new(1, 0, 1, 0)
Comments_.Font = Enum.Font.Code
Comments_.Text = ""
Comments_.TextColor3 = Color3.fromRGB(87, 166, 74)
Comments_.TextSize = 14.000
Comments_.TextXAlignment = Enum.TextXAlignment.Left
Comments_.TextYAlignment = Enum.TextYAlignment.Top

Custom_.Name = "Custom_"
Custom_.Parent = Code
Custom_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Custom_.BackgroundTransparency = 1.000
Custom_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Custom_.BorderSizePixel = 0
Custom_.Size = UDim2.new(1, 0, 1, 0)
Custom_.ZIndex = 2
Custom_.Font = Enum.Font.Code
Custom_.Text = ""
Custom_.TextColor3 = Color3.fromRGB(97, 175, 239)
Custom_.TextSize = 14.000
Custom_.TextXAlignment = Enum.TextXAlignment.Left
Custom_.TextYAlignment = Enum.TextYAlignment.Top

Tokens_.Name = "Tokens_"
Tokens_.Parent = Code
Tokens_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Tokens_.BackgroundTransparency = 1.000
Tokens_.BorderColor3 = Color3.fromRGB(27, 42, 53)
Tokens_.BorderSizePixel = 0
Tokens_.Size = UDim2.new(1, 0, 1, 0)
Tokens_.ZIndex = 2
Tokens_.Font = Enum.Font.Code
Tokens_.Text = ""
Tokens_.TextColor3 = Color3.fromRGB(180, 180, 180)
Tokens_.TextSize = 14.000
Tokens_.TextXAlignment = Enum.TextXAlignment.Left
Tokens_.TextYAlignment = Enum.TextYAlignment.Top

Lines.Name = "Lines"
Lines.Parent = Scroll
Lines.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Lines.BackgroundTransparency = 1.000
Lines.BorderColor3 = Color3.fromRGB(27, 42, 53)
Lines.BorderSizePixel = 0
Lines.Position = UDim2.new(0.0138338944, 0, 0, 0)
Lines.Size = UDim2.new(0.0150776841, 0, 1, 0)
Lines.Font = Enum.Font.SourceSans
Lines.Text = "  1"
Lines.TextColor3 = Color3.fromRGB(255, 255, 255)
Lines.TextSize = 14.000
Lines.TextXAlignment = Enum.TextXAlignment.Left
Lines.TextYAlignment = Enum.TextYAlignment.Top

LLine.Name = "LLine"
LLine.Parent = Scroll
LLine.BackgroundColor3 = Color3.fromRGB(81, 81, 81)
LLine.BorderColor3 = Color3.fromRGB(27, 42, 53)
LLine.BorderSizePixel = 0
LLine.Position = UDim2.new(0.0350000001, 0, 0, 0)
LLine.Size = UDim2.new(0, 1, 1, 0)
LLine.ZIndex = 50

Execute.Name = "Execute"
Execute.Parent = Frame
Execute.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Execute.BorderColor3 = Color3.fromRGB(182, 182, 182)
Execute.Position = UDim2.new(0.0357143246, 0, 0.902251661, 0)
Execute.Size = UDim2.new(0, 132, 0, 18)
Execute.Font = Enum.Font.SourceSans
Execute.Text = "▶   Execute"
Execute.TextColor3 = Color3.fromRGB(234, 234, 234)
Execute.TextSize = 14.000

Clear.Name = "Clear"
Clear.Parent = Frame
Clear.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Clear.BorderColor3 = Color3.fromRGB(182, 182, 182)
Clear.Position = UDim2.new(0.346206814, 0, 0.902251661, 0)
Clear.Size = UDim2.new(0, 139, 0, 18)
Clear.Font = Enum.Font.SourceSans
Clear.Text = "⊘   Clear"
Clear.TextColor3 = Color3.fromRGB(234, 234, 234)
Clear.TextSize = 14.000

Attach.Name = "Attach"
Attach.Parent = Frame
Attach.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Attach.BorderColor3 = Color3.fromRGB(182, 182, 182)
Attach.Position = UDim2.new(0.671688616, 0, 0.902251661, 0)
Attach.Size = UDim2.new(0, 136, 0, 18)
Attach.Font = Enum.Font.SourceSans
Attach.Text = "ⓘ    Attach"
Attach.TextColor3 = Color3.fromRGB(234, 234, 234)
Attach.TextSize = 14.000

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0.0342612416, 0, 0.0329670347, 0)
TextLabel.Size = UDim2.new(0, 178, 0, 20)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "XP Executor Internal"
TextLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
TextLabel.TextSize = 25.000

Close.Name = "Close"
Close.Parent = Frame
Close.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Close.BackgroundTransparency = 1.000
Close.BorderColor3 = Color3.fromRGB(182, 182, 182)
Close.BorderSizePixel = 0
Close.Position = UDim2.new(0.917941332, 0, 0.0377827734, 0)
Close.Size = UDim2.new(0, 21, 0, 19)
Close.Font = Enum.Font.SourceSansBold
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(234, 234, 234)
Close.TextSize = 20.000

Open.Name = "Open"
Open.Parent = ScreenGui
Open.BackgroundColor3 = Color3.fromRGB(57, 57, 57)
Open.BorderColor3 = Color3.fromRGB(0, 0, 0)
Open.BorderSizePixel = 0
Open.Position = UDim2.new(0.458781362, 0, 0.491787106, 0)
Open.Size = UDim2.new(0, 122, 0, 34)
Open.Visible = false
Open.Font = Enum.Font.SourceSansBold
Open.Text = "Open XP"
Open.TextColor3 = Color3.fromRGB(240, 240, 240)
Open.TextSize = 20.000

UICorner_2.Parent = Open

-- Scripts:

local function REKHOHI_fake_script() -- Scroll.Editor 
	local script = Instance.new('LocalScript', Scroll)

	-- edited with <3 by nosyliam
	
	-- 1x1x1x1 was not here
	
	local lua_keywords = {"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"}
	local global_env = {"getrawmetatable", "game", "workspace", "script", "math", "string", "table", "print", "wait", "BrickColor", "Color3", "next", "pairs", "ipairs", "select", "unpack", "Instance", "Vector2", "Vector3", "CFrame", "Ray", "UDim2", "Enum", "assert", "error", "warn", "tick", "loadstring", "_G", "shared", "getfenv", "setfenv", "newproxy", "setmetatable", "getmetatable", "os", "debug", "pcall", "ypcall", "xpcall", "rawequal", "rawset", "rawget", "tonumber", "tostring", "type", "typeof", "_VERSION", "coroutine", "delay", "require", "spawn", "LoadLibrary", "settings", "stats", "time", "UserSettings", "version", "Axes", "ColorSequence", "Faces", "ColorSequenceKeypoint", "NumberRange", "NumberSequence", "NumberSequenceKeypoint", "gcinfo", "elapsedTime", "collectgarbage", "PhysicalProperties", "Rect", "Region3", "Region3int16", "UDim", "Vector2int16", "Vector3int16"}
	
	local Source = script.Parent:WaitForChild("Code")
	local Lines = Source.Parent:WaitForChild("Lines")
	local Scroll = script.Parent
	
	local Highlight = function(string, keywords)
	    local K = {}
	    local S = string
	    local Token =
	    {
	        ["="] = true,
	        ["."] = true,
	        [","] = true,
	        ["("] = true,
	        [")"] = true,
	        ["["] = true,
	        ["]"] = true,
	        ["{"] = true,
	        ["}"] = true,
	        [":"] = true,
	        ["*"] = true,
	        ["/"] = true,
	        ["+"] = true,
	        ["-"] = true,
	        ["%"] = true,
			[";"] = true,
			["~"] = true
	    }
	    for i, v in pairs(keywords) do
	        K[v] = true
	    end
	    S = S:gsub(".", function(c)
	        if Token[c] ~= nil then
	            return "\32"
	        else
	            return c
	        end
	    end)
	    S = S:gsub("%S+", function(c)
	        if K[c] ~= nil then
	            return c
	        else
	            return (" "):rep(#c)
	        end
	    end)
	  
	    return S
	end
	
	local hTokens = function(string)
	    local Token =
	    {
	        ["="] = true,
	        ["."] = true,
	        [","] = true,
	        ["("] = true,
	        [")"] = true,
	        ["["] = true,
	        ["]"] = true,
	        ["{"] = true,
	        ["}"] = true,
	        [":"] = true,
	        ["*"] = true,
	        ["/"] = true,
	        ["+"] = true,
	        ["-"] = true,
	        ["%"] = true,
			[";"] = true,
			["~"] = true
	    }
	    local A = ""
	    string:gsub(".", function(c)
	        if Token[c] ~= nil then
	            A = A .. c
	        elseif c == "\n" then
	            A = A .. "\n"
			elseif c == "\t" then
				A = A .. "\t"
	        else
	            A = A .. "\32"
	        end
	    end)
	  
	    return A
	end
	
	
	local strings = function(string)
	    local highlight = ""
	    local quote = false
	    string:gsub(".", function(c)
	        if quote == false and c == "\"" then
	            quote = true
	        elseif quote == true and c == "\"" then
	            quote = false
	        end
	        if quote == false and c == "\"" then
	            highlight = highlight .. "\""
	        elseif c == "\n" then
	            highlight = highlight .. "\n"
			elseif c == "\t" then
			    highlight = highlight .. "\t"
	        elseif quote == true then
	            highlight = highlight .. c
	        elseif quote == false then
	            highlight = highlight .. "\32"
	        end
	    end)
	  
	    return highlight
	end
	
	local comments = function(string)
	    local ret = ""
	    string:gsub("[^\r\n]+", function(c)
	        local comm = false
	        local i = 0
	        c:gsub(".", function(n)
	            i = i + 1
	            if c:sub(i, i + 1) == "--" then
	                comm = true
	            end
	            if comm == true then
	                ret = ret .. n
	            else
	                ret = ret .. "\84"
	            end
	        end)
	        ret = ret
	    end)
	    
	    return ret
	end
	
	local numbers = function(string)
	    local A = ""
	    string:gsub(".", function(c)
	        if tonumber(c) ~= nil then
	            A = A .. c
	        elseif c == "\n" then
	            A = A .. "\n"
			elseif c == "\t" then
				A = A .. "\t"
	        else
	            A = A .. "\32"
	        end
	    end)
	  
	    return A
	end
	
	local getCurrentLineLength = function()
		local num = 0
		repeat
			num = num + 1
		until string.sub(Source.Text, Source.CursorPosition - num, Source.CursorPosition - num) == "\n" or (Source.CursorPosition - num <= 0)
		return num
	end
	
	local getCurrentLine = function()
		local lin = 1
		Source.Text:sub(1, Source.CursorPosition):gsub("\n", function()
			lin = lin + 1
		end)
		return lin
	end
	
	local getNumLines = function()
		local lin = 1
		Source.Text:gsub("\n", function()
			lin = lin + 1
		end)
		return lin
	end
	
	local getLongestLine = function()
		local longest, i = 0, 0
		for line in Source.Text:gmatch("([^\r\n]*)[\r\n]?") do
	  		longest = string.len(line) > longest and string.len(line) or longest
		end
		return longest
	end
	
	local getLineInset = function()
		local pos, lineInset = Source.CursorPosition, 0
		repeat
			pos = pos - 1
			lineInset = lineInset + 1
		until string.sub(Source.Text, pos, pos) == "\n" or pos <= 0
		return lineInset
	end
	
	local function Comments(String) -- Edit
		local CommentaryOpen = false
		String = String:gsub("%-%-",function(Commentary) return "\255" end)
		String = String:gsub("\n",function(Commentary) return "\254" end)
		return String:gsub("%S",function(Character)
			if Character == "\255" then
				CommentaryOpen = true
				return "--"
			elseif Character == "\254" then
				CommentaryOpen = false
				return "\n"
			end
			return CommentaryOpen and Character or "\32"
		end)
	end
	
	local highlight_source = function(type)
		if type == "Text" or type == "CursorPosition" then
			Source.Text = Source.Text:gsub("\13", "")
			Source.Text = Source.Text:gsub("\t", "      ")
			local s = Source.Text
			Source.Keywords_.Text = Highlight(s, lua_keywords)
			Source.Globals_.Text = Highlight(s, global_env)
			Source.RemoteHighlight_.Text = Highlight(s, {"FireServer", "fireServer", "InvokeServer", "invokeServer"})
			Source.Tokens_.Text = hTokens(s)
			Source.Numbers_.Text = numbers(s)
			Source.Strings_.Text = strings(s)
			Source.Comments_.Text = Comments(s)
			Lines.Text = ""
			for i = 1, getNumLines() do
				Lines.Text = Lines.Text .. i .. "\n"
			end
			--Lines.Size = UDim2.new(0, 26, 0, math.max(10000, (15 * getNumLines()) + 5))
			Scroll.CanvasSize = UDim2.new(0, 8 * getLongestLine(), 0, (15 * getNumLines()) + 5)
			if Scroll.CanvasPosition.X < (8 * getCurrentLineLength())-276 then
				movedAway = false
			end
			local top = math.floor(Scroll.CanvasPosition.Y / 15) + 2
			local bottom = math.min(top + 16, getNumLines())
			if getCurrentLine() > bottom then
				Scroll.CanvasPosition = Scroll.CanvasPosition + Vector2.new(0, 15)
				if bottom == 15 then
					Scroll.CanvasPosition = Scroll.CanvasPosition + Vector2.new(0, 5)
				end
			end
			if getCurrentLine() < top then
				Scroll.CanvasPosition = Scroll.CanvasPosition + Vector2.new(0, -15)
			end
			if movedAway then
			elseif 8 * getCurrentLineLength() > 266 then
				Scroll.CanvasPosition = Vector2.new((8 * getCurrentLineLength())-266, Scroll.CanvasPosition.Y)
			else
				Scroll.CanvasPosition = Vector2.new(0, Scroll.CanvasPosition.Y)
			end
			if getCurrentLine() == getNumLines() and Source.TextBounds.Y > 240 and (not scrolledAway) then
				Scroll.CanvasPosition = Vector2.new(Scroll.CanvasPosition.X, (getNumLines() * 15) + 5)
			end
			--Source.Size = UDim2.new(0, math.max((getLongestLine() * 8), 266) + 4, 0, math.max(getNumLines() * 15, 250))
			--Lines.Position = UDim2.new(0, 0, 0, -Scroll.CanvasPosition.Y)
		end
	end
	
	local move_lines = function(type)
		if type == "CanvasPosition" then
			Lines.Position = UDim2.new(0, 0, 0, -Scroll.CanvasPosition.Y)
		end
	end
	
	highlight_source("Text")
	
	Source.Changed:Connect(highlight_source)
	Scroll.Changed:Connect(move_lines)
	currentInset, movingUp, movingDown, scrolledAway, movedAway = 0, false, false, false, false
	game:GetService("UserInputService").InputEnded:connect(function(inp)
		if not Source:IsFocused() then highlight_source("Text") end
		highlight_source("Text")
		if inp.UserInputType == Enum.UserInputType.Keyboard then
			if inp.KeyCode == Enum.KeyCode.Left then
				currentInset = getLineInset()
			elseif inp.KeyCode == Enum.KeyCode.Right then
				currentInset = getLineInset()
			elseif inp.KeyCode == Enum.KeyCode.Up then
				movingUp = false
			elseif inp.KeyCode == Enum.KeyCode.Down then
				movingDown = false
			end
		end
	end)
	game:GetService("UserInputService").InputChanged:connect(function(inp)
		if not Source:IsFocused() then return end
		if inp.UserInputType == Enum.UserInputType.TextInput then
			currentInset = getLineInset()
		elseif inp.KeyCode == Enum.KeyCode.Left then
			currentInset = getLineInset()
		elseif inp.KeyCode == Enum.KeyCode.Right then
			currentInset = getLineInset()
		end
		if inp.UserInputType == Enum.UserInputType.MouseWheel then
			scrolledAway = true
			Scroll.CanvasPosition = Scroll.CanvasPosition - Vector2.new(0, 15 * inp.Position.Z)
		end
	end)
	game:GetService("UserInputService").InputBegan:connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			currentInset = getLineInset()
			if (inp.Position.X >= Scroll.AbsolutePosition.X + Scroll.AbsoluteSize.X - 5 and inp.Position.X <= Scroll.AbsolutePosition.X + Scroll.AbsoluteSize.X) then
				scrolledAway = true
				Source:ReleaseFocus()
			end
			if (inp.Position.Y >= Scroll.AbsolutePosition.Y + Scroll.AbsoluteSize.Y - 5 and inp.Position.Y <= Scroll.AbsolutePosition.Y + Scroll.AbsoluteSize.Y) then
				movedAway = true
				Source:ReleaseFocus()
			end
		end
		if not Source:IsFocused() then return end
		highlight_source("Text")
		if inp.KeyCode == Enum.KeyCode.Return then
			Scroll.CanvasPosition = Vector2.new(0, Scroll.CanvasPosition.Y)
			scrolledAway = false
			movedAway = false
		elseif inp.KeyCode == Enum.KeyCode.Up then
			movingUp = true
			waitTime = 0.5
			local function move()
				local pos, pLen = Source.CursorPosition, 0
				repeat
					pos = pos - 1
				until (string.sub(Source.Text, pos, pos) == "\n") or (0 >= pos) -- Go to end of line
				if pos == 0 then wait(waitTime) return end
				repeat -- Go to the start of the previous line
					pos = pos - 1
					pLen = pLen + 1
				until (string.sub(Source.Text, pos, pos) == "\n") or (0 >= pos)
				local inset = currentInset
				Source.CursorPosition = pos + math.min(currentInset, pLen)
				wait(waitTime)
			end
			move()
			if movingUp == false then return end
			waitTime = 0.05
			repeat
				move()
			until movingUp == false
		elseif inp.KeyCode == Enum.KeyCode.Down then
			movingDown = true
			waitTime = 0.5
			local function move()
				local pos, pLen = Source.CursorPosition, 0
				repeat
					pos = pos - 1
				until string.sub(Source.Text, pos, pos) == "\n" or pos > string.len(Source.Text) or 0 >= pos
				repeat -- Go to the start of the next line
					pos = pos + 1
				until string.sub(Source.Text, pos, pos) == "\n" or pos > string.len(Source.Text)
				repeat -- Find length of the next line
					pLen = pLen + 1
				until string.sub(Source.Text, pos + pLen, pos + pLen) == "\n" or pos + pLen > string.len(Source.Text)
				if pos == 0 then wait(waitTime) return end
				local inset = currentInset
				Source.CursorPosition = pos + math.min(currentInset, pLen)
				wait(waitTime)
			end
			move()
			if movingDown == false then return end
			waitTime = 0.05
			repeat
				move()
			until movingDown == false	
		end
	end)
	
	-- you really skidded off of topkek, huh
	
end
coroutine.wrap(REKHOHI_fake_script)()
local function GOWGO_fake_script() -- Execute.Execute 
	local script = Instance.new('LocalScript', Execute)

	script.Parent.MouseButton1Click:Connect(function()
		loadstring(script.Parent.Parent.Scroll.Code.Text)()
	end)
end
coroutine.wrap(GOWGO_fake_script)()
local function LBCIYD_fake_script() -- Clear.Clear 
	local script = Instance.new('LocalScript', Clear)

	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Scroll.Code.Text = ""
	end)
end
coroutine.wrap(LBCIYD_fake_script)()
local function TSIKKK_fake_script() -- Attach.Attach 
	local script = Instance.new('LocalScript', Attach)

	script.Parent.MouseButton1Click:Connect(function()
		local Gui = game:GetService("StarterGui")
	
		Gui:SetCore("SendNotification", {
			Title = "Attached";
			Text = "Already attached, Executor: " .. getexecutorname();
			Duration = 3;
		})
	end)
end
coroutine.wrap(TSIKKK_fake_script)()
local function HEKML_fake_script() -- Close.Close 
	local script = Instance.new('LocalScript', Close)

	script.Parent.MouseButton1Click:Connect(function()
		local Minimize = script.Parent.Parent.Parent.Parent.ScreenGui.Open
		local Frame = script.Parent.Parent.Parent.Frame
		if Frame.Visible == true and Minimize.Visible == false then
			Frame.Visible = false
			Minimize.Visible = true
		end
	end)
end
coroutine.wrap(HEKML_fake_script)()
local function PHBST_fake_script() -- Frame.Drag 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
end
coroutine.wrap(PHBST_fake_script)()
local function EMPDL_fake_script() -- Open.Close 
	local script = Instance.new('LocalScript', Open)

	script.Parent.MouseButton1Click:Connect(function()
		local Frame = script.Parent.Parent.Frame
		if script.Parent.Visible == true and Frame.Visible == false then
			Frame.Visible = true
			script.Parent.Visible = false
		end
	end)
end
coroutine.wrap(EMPDL_fake_script)()
local function MSVVW_fake_script() -- Open.DragUI 
	local script = Instance.new('LocalScript', Open)

	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
end
coroutine.wrap(MSVVW_fake_script)()